<p align="center">
Университет ИТМО<br>
Факультет программной инженерии и компьютерной техники
</p>

<br><br><br>

<p align="center">
<strong>Лабораторная работа №1</strong><br>
По дисциплине «Операционные системы»
</p>

<br><br><br><br>

<p align="right">
Выполнили:<br>
Студенты групп P3311<br>
Сангинов Илёсджон
</p>

<p align="right">
Вариант: proc-clone, shell-seq, cpu-mat-mul, ema-join-nl, cd, pwd
</p>

<br><br><br>

<p align="right">
Преподаватель:<br>
Смирнов Виктор Игоревич
</p>

<br><br><br><br><br>

## 1 Задание

### 1.1 Часть 1. Запуск программ

Необходимо реализовать собственную оболочку командной строки – shell.  
Выбор ОС для реализации производится на усмотрение студента.  
Shell должен предоставлять пользователю возможность: запускать программы на компьютере с переданными аргументами командной строки и после завершения программы показывать время ее работы (показывать самостоятельно как *время завершения* – *время запуска*).

### 1.2 Часть 2. Мониторинг и профилирование

Разработать комплекс программ-нагрузчиков по варианту, заданному преподавателем.  
Каждый нагрузчик должен, как минимум, принимать параметр, который определяет количество повторений для алгоритма, указанных в задании.  
Программы должны нагружать вычислительную систему, дисковую подсистему или подсистемы ввода-вывода.  
Необходимо обеспечить корректное измерение времени работы пилота.

Перед запуском нагрузчика попробуйте оценить время работы вашей программы или ее результатов (если по заданию вам досталось измерение чего-либо).  
Постарайтесь сделать оценку максимально точной. Представьте можно сценарий, чтобы избежать в своей оценке влияния ОС и аппаратных подсистем, используя аппаратное средство.

1. Перед запуском нагрузчика, попробуйте оценить время работы вашей программы или ее результаты (если по варианту вам досталось измерение чего либо) и обоснуйте свои предположения.

2.	Запустите программу-нагрузчик и зафиксируйте метрики ее работы с помощью инструментов для 	    мониторинга и профилирования (см. лекции). Сравните полученные результаты с ожидаемыми. 		Объяснените наблюдаемое поведение. Продолжительность каждого запуска должна занимать достаточное для прекращения переходных процессов время, по крайней мере, минуту.

3. Определите количество одновременно запущенных процессов с программой-нагрузчиком, которое эффективно нагружает все ядра процессора в вашей системе. Как распределяются показатели времени USER%, SYS%, WAIT%, а также полное время выполнения нагрузчика, какое количество переключений контекста (вынужденных и невынужденных) происходит при этом? Подумайте над тем, как вы определяете эффективность.

4. Увеличьте количество нагрузчиков вдвое, втрое, вчетверо. Как изменились исследуемые показатели? Почему?

5. Объедините программы-нагрузчики в одну, реализованную при помощи потоков выполнения, чтобы один нагрузчик эффективно нагружал все ядра вашей системы. Как изменились показатели времени для того же объема вычислений? Запустите одну, две, три таких программы. Как изменились исследуемые показатели? Почему?
6. 	Скомпилируйте программу-нугрузчик с опцией агрессивной оптимизации. Как изменились исследуемые показатели? На сколько сократилось реальное время исполнения программы нагрузчика? Почему?

<br><br><br><br><br>

### 2.Листинг исходного кода

• Командная оболочка (proc-clone, shell-seq):  
  [`shell.c`](./src/shell.c)

• Нагрузчик вычислительной подсистемы (cpu-mat-mul):  
  [`cpu-mat-mul.c`](./src/cpu-mat-mul.c)

• Нагрузчик внешней памяти (ema-join-nl):  
  [`ema-join-nl.c`](./src/ema-join-nl.c)

• IO-нагрузчик:  
  [`io_load.c`](./src/io_load.c)
  
  <br><br><br>
  
### 3.Предположения о свойствах программ-нагрузчиков
#### Предположения о свойствах cpu-mat-mul
Программа cpu-mat-mul реализует умножение матриц .Поэтому ожидаю, что время выполнения будет расти очень быстро при увеличении размера матрицы.Основная нагрузка будет приходиться на USER time, так как весь алгоритм работает в пользовательском пространстве и делает минимальное число системных вызовов.Показатель SYS% будет небольшим, а WAIT% ≈ 0%, потому что программа почти не использует подсистему ввода-вывода.
<br><br>
#### Предположения о свойствах ema-join-nl (Nested Loop Join)
Нагрузчик ema-join-nl выполняет объединение двух таблиц по идентификатору, используя алгоритм Nested Loop Join.
Ожидается, что основная нагрузка придётся на CPU и подсистему памяти, поскольку программа многократно перебирает элементы обеих таблиц и сравнивает идентификаторы.
Подсистема ввода-вывода задействована только при чтении входных файлов и записи результата, поэтому ожидаемые значения WAIT% будут низкими.
Показатель USER% должен быть высоким.
SYS% может немного возрасти при больших объёмах данных из-за более частых обращений к памяти, но останется умеренным.
<br><br>
#### Предположения о свойствах io_load
Последовательный доступ (sequence): При последовательной записи большими блоками (например, 1 MiB) ожидаю высокую пропускную способность, ограниченную скоростью диска и файлового кэша.
При direct=off ОС будет кэшировать данные, поэтому скорость может быть даже выше, а WAIT% — низким.
USER и SYS должны быть небольшими.

Случайный доступ (random): При случайном доступе ожидаю существенное падение пропускной способности из-за большого количества отдельных случайных обращений.
WAIT% в этом режиме возрастёт, так как диск будет чаще ожидать выполнения операций ввода-вывода.

Чтение vs запись: Запись больших блоков должна быть быстрее чтения с direct=on, но при direct=off чтение после первого прохода может быть очень быстрым из-за файлового кэша (данные уже в памяти).

### 4.	Результаты измерений и метрик
